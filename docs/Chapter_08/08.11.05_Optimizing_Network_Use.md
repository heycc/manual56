### 8.11.5. Optimizing Network Use
#### 8.11.5.1. How MySQL Uses Threads for Client Connections
连接管理线程处理服务器监听到网卡上的客户端连接请求。在所有平台上，一个管理线程处理TCP/IP连接请求。在Unix上，这个管理线程同样处理Unix socket文件连接请求。在windows上，一个管理线程处理共享内存处理请求，其他的线程处理命名管道连接请求。服务器不会创建线程处理他不监听的接口。例如，一个不支持命令管道连接的windows服务器不会创建一个线程处理这些连接。

连接管理线程使每个客户端连接与专属于这个连接的线程关联，为这个连接处理认证和处理请求。当需要时，连接管理线程会创建一个新线程，但是首先会查看线程缓存池是否存在一个线程能被这个连接使用。当一个连接结束，如果缓存池未满，这个线程将返回到线程池。

在这种连接线程模型中，客户端连接的数目和线程个数一样，当服务器的工作负载必须扩展以处理大量的连接请求时，有些劣势。例如，线程创建和销毁将变得昂贵。同样，每个线程要求服务器和内核资源，比如栈空间。为容纳大量同时存在的连接，每个线程的栈大小必须控制的很小，导致要么太小要么服务器消耗大量的内存。也可能出现耗尽其他资源，并且调度瓶颈可能变的重要。

在MYSQL5.6.10，商业版的MYSQL5.6包含一个线程池插件，它提供一个可选择的线程模型，该线程模型被设计为减少瓶颈和提高性能。它实现一个线程池，通过高效管理具有大量客户端连接数的线程执行语句来增加服务器性能。查看[Section 08.11.06, “The Thread Pool Plugin”.][08.11.06]
[08.11.06]: ./docs/Chapter_08/08.11.06_The_Thread_Pool_Plugin.md
为控制和监控服务器管理线程如何处理客户端连接，几个系统和状态变量相关。查看[Section 05.01.04, “Server System Variables”][05.01.04], 及[Section 05.01.06, “Server Status Variables”][05.01.06]
[05.01.04]: ./docs/Chapter_05/05.01.04_Server_System_Variables.md
[05.01.06]: ./docs/Chapter_05/05.01.06_Server_Status_Variables.md
线程缓存的大小由[thread_cache_size](#) [566]系统变量决定。缺省值是0（无缓存），这将为每个新连接创建一个线程，当连接终止就释放它。设置[thread_cache_size](#) [566]为N以允许N个不活动的连接被缓存。[thread_cache_size](#) [566]能在服务器启动时设置或者在服务器运行时修改。一个连接线程变的不活动当它相关的客户端线程终止。

为监控缓存池中线程个数，及因为不能从缓存中获取线程创建了多少线程，监控[Threads_cached](#) [617]和[Threads_created](#) [617]状态变量。

你可以在服务器启动时设置[max_connections](#) [518]或者在运行时控制能同时连接的客户端最大值。

当线程栈太小，它限制了服务器能处理的SQL语句的复杂度，存储过程回调深度，及其他消耗内存的行为。为每个线程设置N字节的栈大小，以[--thread_stack=N](#) [570]启动服务。
#### 8.11.5.2. DNS Lookup Optimization and the Host Cache
MYSQL服务器在内存中维护一个主机缓存，包含客户端信息：IP地址，主机名，和错误信息。服务器对非本地TCP连接使用这个缓存。使用回环接口地址（127.0.0.1或者：：1）建立的TCP连接，或者使用Unix socket文件，命令管道，或者共享内存的连接不会使用缓存。

对每个新的客户端连接，服务器使用客户端IP地址检查客户端主机名是否在主机缓存中。如果不在，服务器尝试解析主机名。首先，它解析IP地址为一个主机名，然后将主机名解析回IP地址。然后，它将结果与原始的IP地址比较以确保它们相同。服务器将这个操作结果的信息存储在主机缓存中。如果缓存满，最近最少使用的条目将被丢弃。

[host_cache](#)性能模式表揭露了主机缓存的内容，因此可以使用[select](#)语句检查。这有助于你诊断连接错误。查看[Section 21.09.09.01, “The host_cache Table”][21.09.09.01]
[21.09.09.01]: ./docs/Chapter_21/21.09.09_The_host_cache_Table.md#21.09.09.01

服务器如下处理主机缓存中的条目：

1.当第一个TCP客户端从给定的IP地址到达服务器，一个新条目被创建以记录客户端IP，主机名，和客户端查找确认标识。初始，主机名被设置为[NULL](#)和标识为假。这个条目同样被用于之后来自于原始相同IP的客户端连接。

2.如果客户端条目的确认标识为假，服务器尝试一个IP到主机名的DNS解析。如果成功，主机名被更新为解析的主机名，然后确认标识被设置为真。如果解析不成功，行动取决于错误是永久的还是临时的。对永久的错误，主机名仍然为[NULL](#)，确认标识设置为真。对临时错误，主机名和确认标识仍然不改变。（其他的DNS解析试图在这个IP的客户端连接下次发生时解析。）

3.当正在处理一个给定IP地址的客户端连接时，发生错误，服务器更新那个IP条目中的相关错误计数。对一个错误记录的信息，查看[Section 21.09.09.01, “The host_cache Table”][21.09.09.01]
[21.09.09.01]: ./docs/Chapter_21/21.09.09_The_host_cache_Table.md#21.09.09.01

服务器完成主机名解析使用线程安全的gethostbyaddr\_r()和gethostbyname\_r()调用，如果操作系统支持它们。否则，线程完成查找锁一个互斥变量然后调用gethostbyaddr\_r()和gethostbyname\_r()。在这种情况下，没有其他线程可以解析不在主机缓存中的主机名，直到持有互斥锁的线程释放它。

服务器使用主机缓存达到几个目标：

- 通过缓存IP到主机名的结果，服务器避免为每个客户端连接执行DNS查询。相反，对一个给定的主机，它仅需要完成从那个主机的第一次连接的查询。
- 缓存包含连接处理过程中的错误信息。一些错误被认为是“阻塞”，如果太多这样的阻塞从一个给定的主机连续的发生而没有成功的连接，服务器阻塞从这个主机的将来的连接。[max_connect_errors](#) [517]系统变量决定在阻塞之前允许发生的错误数。查看[Section C.05.02.06, “Host 'host_name' is blocked”][05.02.06]
[05.02.06]: ./docs/Chapter_05/05.02.06_Host_host_name_is_blocked.md

解除阻塞的主机，通过使用[FLUSH HOSTS](#)语句刷新主机缓存或者执行[mysqladmin flush-hosts](#)命令。

将一个阻塞的主机变成非阻塞即使没有使用[FLUSH HOSTS](#)时可能的，如果其他的主机到达了，自从阻塞的主机最后一次试图访问。这是因为服务器丢弃最少最近使用的条目为新的条目创造空间，当缓存满且来自于一个IP地址不再缓存中的连接。如果丢弃的条目是一个阻塞的主机，然后主机变为不阻塞。

主机缓存缺省打开。为关闭它，设置[host\\_cache_size](#) [502]系统变量为0，要么在系统启动时或者运行时。

关闭DNS主机查询解析，以[--skip-name-resolve](#) [454]选项启动服务。在这种情况下，服务器仅仅使用IP地址，不使用主机名匹配MYSQL授权表中的记录。仅仅这些表中使用IP地址的账户能被使用。

如果你有非常慢的DNS和许多主机，你可以要么通过使用[--skip-name-resolve](#) [454]关闭DNS查询或者增加[host_cache_size](#) [502]是主机缓存更大，改进性能。

完全不接受TCP/IP连接，以[--skip-networking](#) [454]启动选项。

一些连接错误与TCP连接无关，在连接处理的很早发生（即使IP地址被知道之前），或者没有被说明为任何特别的地址（比如内存不足）。获取这些错误的信息，检查[Connection_errors_xxx ](#)[603]系统变量（查看 [ Section 05.01.06, “Server Status Variables”][05.01.06]）
[05.01.06]: ./docs/Chapter_05/05.01.06_Server_Status_Variables.md