### 8.10.4. Metadata Locking
MYSQL使用元数据锁管理对象的访问（表，触发器，及等等）。元数据锁用于确保数据一致性但是确实包含一些开销随着查询大量增加而增加。多个查询试图访问相同的对象越多，元数据锁的竞争增加越多。

元数据锁不是表定义情况的一种替代，它的互斥量和锁与LOCK_OPEN互斥量不同。下面的讨论提供了元数据锁如何工作的信息。

为确保事务可串行化，服务器不允许一个会话在表上完成数据定义语句（DDL），这个表在其他会话的未完成事务使用。服务器通过获得事务内使用的表上元数据锁，及延迟锁的释放直到事务结束来完成。表上的元数据锁组织对表结构的修改。这个锁方法含义是一个会话内事务使用的表不能被其他会话使用DDL语句，直到该事务结束。

这个原则不仅应用于事务表，而且非事务表。假设一个会话开始一个使用事务表t和非事务表nt的事务：

    START TRANSACTION; 
    SELECT * FROM t; 
    SELECT * FROM nt;

表t和nt都持有元数据锁直到事务结束。如果其他的事务试图在任何一个表上DDL操作，它将阻塞直到事务结束释放锁。例如，如果第二个会话试图执行下面任何操作将被阻塞：

    DROP TABLE t; 
    ALTER TABLE t ...; 
    DROP TABLE nt; 
    ALTER TABLE nt ...;

如果服务器为一条语句获取元数据锁，语法有效但是执行期间失败，服务器不会提前释放锁。锁仍然会延迟到事务结束释放，因为失败的语句被写到二进制日志及锁保护日志一致性。

自动提交模式，每条语句事实上是一个事务，因此语句获得的元数据库锁仅持有到语句结束。

在PREPARE语句期间获得的元数据锁，一旦语句完成准备释放，即使准备发生在多语句的事务中。

在MYSQL5.5，当一个事务获取语句内使用表上的元数据锁，语句执行结束后释放锁。这种方法有个劣势：如果DDL语句发生在一个被其他会话的活动事务使用的表上，语句可能以错误的顺序写到二进制日志中。